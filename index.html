<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Vector Tanks</title>

    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#000000"/>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Vector Tanks">
    <link rel="apple-touch-icon" href="https://placehold.co/192x192/000000/00f7ff?text=VT">
    <link rel="manifest" href="data:application/manifest+json;base64,ew0KICAibmFtZSI6ICJWZWN0b3IgVGFua3MiLA0KICAic2hvcnRfbmFtZSI6ICJWRGFua3MiLA0KICAiaWNvbnMiOiBbDQogICAgew0KICAgICAgInNyYyI6ICJodHRwczovL3BsYWNlaG9sZC5jby8xOTJ4MTkyLzAwMDAwMC8wMGY3ZmY/dGV4dD1WVCIsDQogICAgICAic2l6ZXMiOiAiMTkyeDE5MiIsDQogICAgICAidHlwZSI6ICJpbWFnZS9wbmciDQogICAgfSwNCiAgICB7DQogICAgICAic3JjIjogImh0dHBzOi8vcGxhY2Vob2xkLmNvLzUxMng1MTIvMDAwMDAwLzAwZjdmZj90ZXh0PVZUIiwNCiAgICAgICJzaXplcyI6ICI1MTJ4NTEyIiwNCiAgICAgICJ0eXBlIjogImltYWdlL3BuZyINCiAgICB9DQogIF0sDQogICJ0aGVtZV9jb2xvciI6ICIjMDAwMDAwIiwNCiAgImJhY2tncm91bmRfY29sb3IiOiAiIzAwMDAwMCIsDQogICJzdGFydF91cmwiOiAiLiIsDQogICJkaXNwbGF5IjogInN0YW5kYWxvbmUiLA0KICAib3JpZW50YXRpb24iOiAibGFuZHNjYXBlIg0KfQ==">

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #000;
            color: #00f7ff;
            font-family: 'VT323', monospace;
            overflow: hidden;
            touch-action: none;
            display: flex;
            flex-direction: column;
            height: 100vh; /* Use viewport height */
            width: 100vw;
            font-size: 1.25rem;
        }
        .neon-text {
            text-shadow: 0 0 5px #00f7ff, 0 0 10px #00f7ff, 0 0 20px #00f7ff, 0 0 40px #00f7ff, 0 0 80px #00f7ff;
        }
        .neon-box {
            box-shadow: 0 0 5px #00f7ff, 0 0 10px #00f7ff, 0 0 20px #00f7ff inset;
            border: 2px solid #00f7ff;
        }
        .neon-button {
            background-color: #0d1a1a;
            border: 2px solid #00f7ff;
            color: #00f7ff;
            text-shadow: 0 0 5px #00f7ff;
            box-shadow: 0 0 5px #00f7ff, 0 0 10px #00f7ff;
            transition: all 0.3s ease;
        }
        .neon-button:hover, .neon-button:active {
            background-color: #00f7ff;
            color: #000;
            box-shadow: 0 0 10px #00f7ff, 0 0 20px #00f7ff, 0 0 40px #00f7ff;
        }
        .health-bar-inner {
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            box-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00;
        }
        
        /* Mobile Layout Split */
        body.mobile-layout #canvasContainer {
            height: 50%;
            flex-shrink: 0;
        }
        body.mobile-layout #mobileControlsContainer {
            height: 50%;
            display: block;
        }

        #mobileControls .d-pad, #mobileControls .action-buttons {
            position: absolute;
            transform: scale(var(--control-scale, 1));
            opacity: var(--control-opacity, 0.7);
            transition: outline .2s;
        }
        .is-adjusting .d-pad, .is-adjusting .action-buttons {
            outline: 2px dashed #ff00ff;
            cursor: move;
        }

        .d-pad button, .action-buttons button {
            background-color: rgba(128, 128, 128, 0.3);
            border: 2px solid #555;
            color: white;
            transition: background-color 0.2s;
        }
        .d-pad button:active, .action-buttons button:active {
            background-color: rgba(128, 128, 128, 0.7);
        }
        .action-buttons .button-a {
            background-color: rgba(255, 0, 255, 0.5);
        }
        .action-buttons .button-b {
            background-color: rgba(255, 0, 255, 0.5);
        }
        #gameCanvas {
            box-shadow: 0 0 10px #00f7ff, 0 0 20px #00f7ff, 0 0 30px #00f7ff, 0 0 40px #00f7ff;
            border: 2px solid #00f7ff;
            transition: box-shadow 0.1s ease-in-out, border-color 0.1s ease-in-out;
        }
        .modal {
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }
        #controlAdjustModal {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 60;
        }
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #00f7ff;
            cursor: pointer;
            margin-top: -8px;
            box-shadow: 0 0 10px #00f7ff;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #00f7ff;
            border-radius: 2px;
        }

        /* Mobile Font Size Adjustment */
        @media (max-width: 767px) {
            #gameUI {
                font-size: 0.875rem; /* Smaller font for mobile UI */
            }
        }
    </style>
</head>
<body class="p-2">

    <!-- Game UI -->
    <div id="gameUI" class="w-full max-w-4xl mx-auto flex justify-between items-center p-2 neon-text hidden">
        <div>Score: <span id="score">0</span></div>
        <div>Hi-Score: <span id="hiScore">0</span></div>
        <div>Enemies Left: <span id="enemiesLeft">0</span></div>
        <div class="flex items-center">
            Health:
            <div class="w-24 h-4 bg-gray-800 border-2 border-cyan-400 rounded-full ml-2 overflow-hidden">
                <div id="healthBar" class="h-full rounded-full health-bar-inner" style="width: 100%;"></div>
            </div>
        </div>
        <button id="pauseButton" class="px-4 py-2 rounded-lg neon-button">Pause</button>
    </div>

    <!-- Game Canvas Container -->
    <div id="canvasContainer" class="flex-grow w-full flex items-center justify-center my-2 relative hidden">
        <canvas id="gameCanvas" class="bg-black rounded-lg"></canvas>
        <!-- Control Adjustment Modal will be injected here for mobile -->
    </div>

    <!-- Mobile Controls Container -->
    <div id="mobileControlsContainer" class="w-full relative hidden">
         <div id="mobileControls" class="absolute inset-0 pointer-events-none">
            <div class="d-pad grid grid-cols-3 gap-2 w-36 h-36 pointer-events-auto" data-control="dpad">
                <div></div><button id="upBtn" class="col-start-2 rounded-md">&#9650;</button><div></div>
                <button id="leftBtn" class="rounded-md">&#9664;</button><div></div><button id="rightBtn" class="rounded-md">&#9654;</button>
                <div></div><button id="downBtn" class="col-start-2 rounded-md">&#9660;</button><div></div>
            </div>
            <div class="action-buttons flex flex-col gap-4 pointer-events-auto" data-control="actions">
                <button id="fireBtn" class="w-20 h-20 rounded-full text-2xl font-bold button-a">A</button>
                <button id="turretBtn" class="w-20 h-20 rounded-full text-2xl font-bold button-b">B</button>
            </div>
        </div>
    </div>
    
    <!-- Start Screen Modal -->
    <div id="startModal" class="fixed inset-0 z-50 modal flex items-center justify-center">
        <div class="bg-black border-2 border-cyan-400 p-8 rounded-lg text-center neon-box">
            <h2 class="text-4xl mb-8 neon-text">VECTOR TANKS</h2>
            <p class="mb-6">Select Control Type:</p>
            <button id="desktopStart" class="w-full mb-4 px-4 py-2 rounded-lg neon-button">Desktop (Keyboard)</button>
            <button id="mobileStart" class="w-full px-4 py-2 rounded-lg neon-button">Mobile (Touch)</button>
        </div>
    </div>

    <!-- Pause Modal -->
    <div id="pauseModal" class="fixed inset-0 z-50 modal items-center justify-center hidden">
        <div class="bg-black border-2 border-cyan-400 p-8 rounded-lg text-center neon-box">
            <h2 class="text-3xl mb-6 neon-text">Paused</h2>
            <button id="resumeButton" class="w-full mb-4 px-4 py-2 rounded-lg neon-button">Resume</button>
            <button id="restartButton" class="w-full mb-4 px-4 py-2 rounded-lg neon-button">Restart Game</button>
            <button id="adjustControlsButton" class="w-full mb-4 px-4 py-2 rounded-lg neon-button hidden">Adjust Controls</button>
            <div id="mobileLayoutOptions" class="text-left mt-4 hidden">
                <h3 class="text-xl mb-2 neon-text">Handedness</h3>
                <label class="flex items-center space-x-2 cursor-pointer">
                    <input type="radio" name="layout" value="left" id="layoutLeft" class="form-radio text-cyan-400">
                    <span>Left</span>
                </label>
                <label class="flex items-center space-x-2 cursor-pointer">
                    <input type="radio" name="layout" value="right" id="layoutRight" class="form-radio text-cyan-400" checked>
                    <span>Right</span>
                </label>
            </div>
        </div>
    </div>
    
    <!-- Control Adjustment Modal Template -->
    <template id="controlAdjustModalTemplate">
        <div id="controlAdjustModal" class="modal items-center justify-center flex">
            <div class="bg-black border-2 border-cyan-400 p-8 rounded-lg text-center neon-box w-11/12 max-w-md">
                <h2 class="text-3xl mb-6 neon-text">Adjust Controls</h2>
                <p class="mb-4 text-sm">Drag controls to move them.</p>
                <div class="space-y-4 text-left">
                    <div>
                        <label for="scaleSlider" class="block mb-1">Size</label>
                        <input id="scaleSlider" type="range" min="0.5" max="1.5" step="0.1" value="1">
                    </div>
                    <div>
                        <label for="opacitySlider" class="block mb-1">Opacity</label>
                        <input id="opacitySlider" type="range" min="0.2" max="1" step="0.1" value="0.7">
                    </div>
                </div>
                <button id="closeAdjustControls" class="w-full mt-8 px-4 py-2 rounded-lg neon-button">Done</button>
            </div>
        </div>
    </template>

    <!-- Game Over Modal -->
    <div id="gameOverModal" class="fixed inset-0 z-50 modal items-center justify-center hidden">
        <div class="bg-black border-2 border-cyan-400 p-8 rounded-lg text-center neon-box w-11/12 max-w-md">
            <h2 class="text-3xl mb-6 neon-text">User has been Derezzed.</h2>
            <div class="text-left space-y-2 mb-6">
                <p>Tanks Derezzed: <span id="statTanks">0</span></p>
                <p>Shots Fired: <span id="statShots">0</span></p>
                <p>Power-ups Collected: <span id="statPowerUps">0</span></p>
                <p>Levels Completed: <span id="statLevels">0</span></p>
                <p>Final Score: <span id="statScore">0</span></p>
            </div>
            <p class="mb-6 neon-text">&lt;&lt;End of Line&gt;&gt;</p>
            <button id="playAgainButton" class="w-full px-4 py-2 rounded-lg neon-button">Play Again</button>
        </div>
    </div>
    
    <!-- Level Complete Modal -->
    <div id="levelCompleteModal" class="fixed inset-0 z-50 modal items-center justify-center hidden">
        <div class="bg-black border-2 border-cyan-400 p-8 rounded-lg text-center neon-box">
            <h2 id="levelCompleteText" class="text-3xl mb-4 neon-text">Level 1 Complete</h2>
            <p id="levelProceedText" class="mb-6">Proceeding to Level 2...</p>
            <p id="levelCountdown" class="text-5xl neon-text">3</p>
        </div>
    </div>

    <script>
        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const hiScoreEl = document.getElementById('hiScore');
        const enemiesLeftEl = document.getElementById('enemiesLeft');
        const healthBarEl = document.getElementById('healthBar');
        const pauseButton = document.getElementById('pauseButton');
        const pauseModal = document.getElementById('pauseModal');
        const resumeButton = document.getElementById('resumeButton');
        const restartButton = document.getElementById('restartButton');
        const gameOverModal = document.getElementById('gameOverModal');
        const playAgainButton = document.getElementById('playAgainButton');
        const mobileControls = document.getElementById('mobileControls');
        const mobileControlsContainer = document.getElementById('mobileControlsContainer');
        const layoutLeftRadio = document.getElementById('layoutLeft');
        const layoutRightRadio = document.getElementById('layoutRight');
        const startModal = document.getElementById('startModal');
        const desktopStartBtn = document.getElementById('desktopStart');
        const mobileStartBtn = document.getElementById('mobileStart');
        const gameUI = document.getElementById('gameUI');
        const canvasContainer = document.getElementById('canvasContainer');
        const adjustControlsButton = document.getElementById('adjustControlsButton');
        const mobileLayoutOptions = document.getElementById('mobileLayoutOptions');
        const levelCompleteModal = document.getElementById('levelCompleteModal');
        const levelCompleteText = document.getElementById('levelCompleteText');
        const levelProceedText = document.getElementById('levelProceedText');
        const levelCountdown = document.getElementById('levelCountdown');
        // Game Over Stat Elements
        const statTanks = document.getElementById('statTanks');
        const statShots = document.getElementById('statShots');
        const statPowerUps = document.getElementById('statPowerUps');
        const statLevels = document.getElementById('statLevels');
        const statScore = document.getElementById('statScore');

        let TILE_SIZE = 32;
        let prevTileSize = 32;
        const MAZE_WIDTH = 21;
        const MAZE_HEIGHT = 15;

        let player, enemies, projectiles, powerUps;
        let score = 0;
        let hiScore = localStorage.getItem('tronTanksHiScore') || 0;
        let level = 1;
        // Stat tracking variables
        let tanksDerezzed = 0;
        let shotsFired = 0;
        let powerUpsCollected = 0;

        let isPaused = false;
        let isAdjustingControls = false;
        let isLevelTransition = false;
        let isGameOver = false;
        let gameStarted = false;
        let isMobile = false;
        let maze = [];
        let powerUpSpawnTimer = 0;
        let mazeCanvas, mazeCtx;

        // Delta Time variables
        let lastTime = 0;
        const TARGET_FPS = 60;
        const timeStep = 1 / TARGET_FPS;


        const keys = {
            ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
            ' ': false, Shift: false
        };

        // --- Helper Functions ---
        function hexToRgba(hex, alpha = 1) {
            if (!hex || hex.length < 7) return `rgba(255, 255, 255, ${alpha})`;
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // --- Game Classes ---
        class Tank {
            constructor(x, y, color, isPlayer = false) {
                this.x = x; this.y = y; this.color = color; this.isPlayer = isPlayer;
                this.width = TILE_SIZE * 0.8; this.height = TILE_SIZE * 0.8;
                this.speed = 120; // Speed in pixels per second
                this.turretAngle = 0; this.moveDirection = 0;
                this.health = isPlayer ? 100 : 20; this.maxHealth = isPlayer ? 100 : 20;
                this.fireCooldown = 0; 
                this.wanderDirection = Math.floor(Math.random() * 4);
                this.wanderTimer = 1 + Math.random() * 2; // Time in seconds
                if (isPlayer) { this.damageFlashTimer = 0; this.activePowerUp = null; this.powerUpTimer = 0; }
            }
            draw() { const centerX = this.x + this.width / 2, centerY = this.y + this.height / 2; let glowColor = this.color; if (this.isPlayer) { if (this.damageFlashTimer > 0) glowColor = '#ff0000'; else if (this.powerUpTimer > 0 && this.activePowerUp) glowColor = this.activePowerUp.color; } ctx.fillStyle = this.color; ctx.shadowColor = glowColor; ctx.shadowBlur = 15; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.save(); ctx.translate(centerX, centerY); ctx.rotate(this.turretAngle * Math.PI / 2); ctx.fillStyle = '#fff'; ctx.shadowColor = '#fff'; ctx.shadowBlur = 10; ctx.fillRect(-this.width * 0.1, -this.height * 0.6, this.width * 0.2, this.height * 0.7); ctx.restore(); ctx.shadowBlur = 0; }
            update(dt) { if (this.fireCooldown > 0) this.fireCooldown -= dt; if (this.isPlayer) { if (this.damageFlashTimer > 0) this.damageFlashTimer -= dt; if (this.powerUpTimer > 0) { this.powerUpTimer -= dt; if (this.powerUpTimer <= 0) this.activePowerUp = null; } } else { this.aiUpdate(dt); } }
            move(dx, dy, maze, allTanks) { const newX = this.x + dx, newY = this.y + dy; if (!this.checkWallCollision(newX, newY, maze) && !this.checkTankCollision(newX, newY, allTanks)) { this.x = newX; this.y = newY; return true; } return false; }
            checkTankCollision(x, y, allTanks) { for (const otherTank of allTanks) { if (otherTank === this) continue; if (x < otherTank.x + otherTank.width && x + this.width > otherTank.x && y < otherTank.y + otherTank.height && y + this.height > otherTank.y) { return true; } } return false; }
            checkWallCollision(x, y, maze) { const corners = [{x: x, y: y}, {x: x + this.width, y: y}, {x: x, y: y + this.height}, {x: x + this.width, y: y + this.height}]; for (const corner of corners) { const gridX = Math.floor(corner.x / TILE_SIZE), gridY = Math.floor(corner.y / TILE_SIZE); if (maze[gridY] && maze[gridY][gridX] === 1) return true; } return false; }
            fire() { 
                let currentFireCooldown = this.isPlayer ? 0.33 : (1.33 - level * 0.05); 
                if (this.isPlayer && this.activePowerUp && this.activePowerUp.type === 'rapid-fire') currentFireCooldown = 0.08; 
                if (this.fireCooldown <= 0) { 
                    if(this.isPlayer) shotsFired++;
                    const speed = 300; let dx = 0, dy = 0; 
                    const offsetX = this.width / 2, offsetY = this.height / 2; 
                    let startX = this.x + offsetX, startY = this.y + offsetY; 
                    const muzzleOffset = this.width * 0.5; 
                    switch (this.turretAngle) { 
                        case 0: dy = -speed; startY -= muzzleOffset; break; 
                        case 1: dx = speed; startX += muzzleOffset; break; 
                        case 2: dy = speed; startY += muzzleOffset; break; 
                        case 3: dx = -speed; startX -= muzzleOffset; break; 
                    } 
                    let bulletColor = this.color;
                    if (this.isPlayer) {
                        bulletColor = '#00f7ff'; // Default player bullet color
                        if (this.powerUpTimer > 0 && this.activePowerUp) {
                           bulletColor = this.activePowerUp.color;
                        }
                    }
                    projectiles.push(new Projectile(startX, startY, dx, dy, bulletColor)); 
                    this.fireCooldown = currentFireCooldown; 
                } 
            }
            takeDamage(amount) { if (this.isPlayer && this.activePowerUp && this.activePowerUp.type === 'shield') return; this.health -= amount; if (this.isPlayer) this.damageFlashTimer = 0.25; if (this.health <= 0) { this.health = 0; if(this.isPlayer) { isGameOver = true; showGameOverModal(); } } }
            aiUpdate(dt) { const playerGridX = Math.floor(player.x / TILE_SIZE); const playerGridY = Math.floor(player.y / TILE_SIZE); const selfGridX = Math.floor(this.x / TILE_SIZE); const selfGridY = Math.floor(this.y / TILE_SIZE); const allTanks = [player, ...enemies]; let hasLineOfSight = false; if (playerGridX === selfGridX) { hasLineOfSight = true; const startY = Math.min(playerGridY, selfGridY), endY = Math.max(playerGridY, selfGridY); for (let y = startY + 1; y < endY; y++) if (maze[y][playerGridX] === 1) { hasLineOfSight = false; break; } if (hasLineOfSight) this.turretAngle = playerGridY > selfGridY ? 2 : 0; } else if (playerGridY === selfGridY) { hasLineOfSight = true; const startX = Math.min(playerGridX, selfGridX), endX = Math.max(playerGridX, selfGridX); for (let x = startX + 1; x < endX; x++) if (maze[playerGridY][x] === 1) { hasLineOfSight = false; break; } if (hasLineOfSight) this.turretAngle = playerGridX > selfGridX ? 1 : 3; } if (hasLineOfSight) { this.fire(); } this.wanderTimer -= dt; let dx = 0, dy = 0; const aiSpeed = this.speed / 2; switch (this.wanderDirection) { case 0: dy = -aiSpeed; break; case 1: dx = aiSpeed; break; case 2: dy = aiSpeed; break; case 3: dx = -aiSpeed; break; } if (!this.move(dx * dt, dy * dt, maze, allTanks) || this.wanderTimer <= 0) { this.wanderDirection = Math.floor(Math.random() * 4); this.wanderTimer = 1 + Math.random() * 2; } }
        }
        class Projectile { 
            constructor(x, y, dx, dy, color) { this.x = x; this.y = y; this.dx = dx; this.dy = dy; this.radius = 4; this.color = color; } 
            draw() { 
                ctx.save();
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 2);
                gradient.addColorStop(0, hexToRgba(this.color, 1));
                gradient.addColorStop(0.5, hexToRgba(this.color, 0.5));
                gradient.addColorStop(1, hexToRgba(this.color, 0));
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.restore();
            } 
            update(dt) { this.x += this.dx * dt; this.y += this.dy * dt; } 
        }
        class PowerUp { constructor(x, y, type) { this.x = x; this.y = y; this.type = type; this.size = TILE_SIZE * 0.4; this.colors = { 'rapid-fire': '#ff00ff', 'shield': '#ffff00', 'health': '#00ff00' }; this.color = this.colors[type]; } draw() { const centerX = this.x * TILE_SIZE + TILE_SIZE / 2, centerY = this.y * TILE_SIZE + TILE_SIZE / 2; ctx.beginPath(); ctx.arc(centerX, centerY, this.size, 0, Math.PI * 2); ctx.fillStyle = this.color; ctx.shadowColor = this.color; ctx.shadowBlur = 20; ctx.fill(); ctx.closePath(); ctx.shadowBlur = 0; } }
        function generateMaze(width, height) { let matrix = Array(height).fill(null).map(() => Array(width).fill(1)); function carve(x, y) { matrix[y][x] = 0; const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]; directions.sort(() => Math.random() - 0.5); for (let [dx, dy] of directions) { const nx = x + dx * 2, ny = y + dy * 2; if (ny >= 0 && ny < height && nx >= 0 && nx < width && matrix[ny][nx] === 1) { matrix[y + dy][x + dx] = 0; carve(nx, ny); } } } carve(1, 1); let connections = Math.floor((width * height) / 20); for(let i = 0; i < connections; i++) { let x = Math.floor(Math.random() * (width - 2)) + 1, y = Math.floor(Math.random() * (height - 2)) + 1; if(matrix[y][x] === 1) matrix[y][x] = 0; } return matrix; }
        
        function drawMazeToCache() { if (!mazeCanvas) { mazeCanvas = document.createElement('canvas'); mazeCtx = mazeCanvas.getContext('2d'); } mazeCanvas.width = canvas.width; mazeCanvas.height = canvas.height; mazeCtx.strokeStyle = '#00f7ff'; mazeCtx.lineWidth = 2; mazeCtx.shadowColor = '#00f7ff'; mazeCtx.shadowBlur = 10; for (let y = 0; y < MAZE_HEIGHT; y++) { for (let x = 0; x < MAZE_WIDTH; x++) { if (maze[y][x] === 1) { mazeCtx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE); } } } mazeCtx.shadowBlur = 0; }
        function drawCachedMaze() { let glowColor = '#00f7ff'; if (player && player.damageFlashTimer > 0) glowColor = '#ff0000'; else if (player && player.powerUpTimer > 0 && player.activePowerUp) glowColor = player.activePowerUp.color; canvas.style.borderColor = glowColor; canvas.style.boxShadow = `0 0 10px ${glowColor}, 0 0 20px ${glowColor}, 0 0 30px ${glowColor}, 0 0 40px ${glowColor}`; if (mazeCanvas) ctx.drawImage(mazeCanvas, 0, 0); }
        
        function init() { isGameOver = false; maze = generateMaze(MAZE_WIDTH, MAZE_HEIGHT); drawMazeToCache(); player = new Tank(TILE_SIZE * 1.5 - TILE_SIZE/2, TILE_SIZE * 1.5 - TILE_SIZE/2, '#00f7ff', true); enemies = []; const numEnemies = Math.min(3 + level, 10); const occupiedCells = ['1,1']; for (let i = 0; i < numEnemies; i++) { let placed = false; while(!placed) { const x = Math.floor(Math.random() * (MAZE_WIDTH - 2)) + 1; const y = Math.floor(Math.random() * (MAZE_HEIGHT - 2)) + 1; const cell = `${x},${y}`; if (maze[y][x] === 0 && !occupiedCells.includes(cell)) { enemies.push(new Tank(x * TILE_SIZE + (TILE_SIZE - TILE_SIZE * 0.8)/2, y * TILE_SIZE + (TILE_SIZE - TILE_SIZE * 0.8)/2, '#ff8c00')); occupiedCells.push(cell); placed = true; } } } projectiles = []; powerUps = []; powerUpSpawnTimer = 5; updateUI(); }
        function resetGame() { score = 0; level = 1; tanksDerezzed = 0; shotsFired = 0; powerUpsCollected = 0; init(); }
        function nextLevel() { level++; player.health = Math.min(player.maxHealth, player.health + 25); init(); }
        function showLevelCompleteScreen() {
            isLevelTransition = true;
            levelCompleteText.textContent = `Level ${level} Complete`;
            levelProceedText.textContent = `Proceeding to Level ${level + 1}...`;
            levelCompleteModal.classList.remove('hidden');
            levelCompleteModal.classList.add('flex');
            let count = 3;
            levelCountdown.textContent = count;
            const interval = setInterval(() => {
                count--;
                levelCountdown.textContent = count;
                if (count === 0) {
                    clearInterval(interval);
                    levelCompleteModal.classList.add('hidden');
                    levelCompleteModal.classList.remove('flex');
                    isLevelTransition = false;
                    nextLevel();
                }
            }, 1000);
        }
        function spawnPowerUp() { const types = ['rapid-fire', 'shield', 'health']; const type = types[Math.floor(Math.random() * types.length)]; let placed = false; while(!placed) { const x = Math.floor(Math.random() * (MAZE_WIDTH - 2)) + 1, y = Math.floor(Math.random() * (MAZE_HEIGHT - 2)) + 1; if (maze[y][x] === 0) { powerUps.push(new PowerUp(x, y, type)); placed = true; } } }
        function update(dt) { if (isPaused || isGameOver || !gameStarted || isAdjustingControls || isLevelTransition) return; const allTanks = [player, ...enemies]; const playerSpeed = (keys.Shift ? player.speed / 2 : player.speed) * dt; if (!keys.Shift) { if (keys.ArrowUp) { player.move(0, -playerSpeed, maze, allTanks); player.moveDirection = 0; } if (keys.ArrowDown) { player.move(0, playerSpeed, maze, allTanks); player.moveDirection = 2; } if (keys.ArrowLeft) { player.move(-playerSpeed, 0, maze, allTanks); player.moveDirection = 3; } if (keys.ArrowRight) { player.move(playerSpeed, 0, maze, allTanks); player.moveDirection = 1; } } else { if (keys.ArrowUp) player.turretAngle = 0; if (keys.ArrowDown) player.turretAngle = 2; if (keys.ArrowLeft) player.turretAngle = 3; if (keys.ArrowRight) player.turretAngle = 1; } if (keys[' ']) player.fire(); player.update(dt); enemies.forEach(e => e.update(dt)); projectiles.forEach(p => p.update(dt)); handleCollisions(); projectiles = projectiles.filter(p => p.x > 0 && p.x < canvas.width && p.y > 0 && p.y < canvas.height); if (enemies.length === 0) showLevelCompleteScreen(); powerUpSpawnTimer -= dt; if (powerUpSpawnTimer <= 0) { if (powerUps.length < 3) spawnPowerUp(); powerUpSpawnTimer = 10 + Math.random() * 5; } }
        function handleCollisions() { projectiles = projectiles.filter(p => { const gridX = Math.floor(p.x / TILE_SIZE), gridY = Math.floor(p.y / TILE_SIZE); return !(maze[gridY] && maze[gridY][gridX] === 1); }); for (let i = projectiles.length - 1; i >= 0; i--) { const p = projectiles[i]; let hit = false; if (p.color !== player.color && p.x > player.x && p.x < player.x + player.width && p.y > player.y && p.y < player.y + player.height) { player.takeDamage(10 + level); hit = true; } else { for (let j = enemies.length - 1; j >= 0; j--) { const e = enemies[j]; if (p.color !== e.color && p.x > e.x && p.x < e.x + e.width && p.y > e.y && p.y < e.y + e.height) { e.takeDamage(20); if (e.health <= 0) { enemies.splice(j, 1); score += 100 * level; tanksDerezzed++; } hit = true; break; } } } if (hit) projectiles.splice(i, 1); } for (let i = powerUps.length - 1; i >= 0; i--) { const pu = powerUps[i]; const puCenterX = pu.x * TILE_SIZE + TILE_SIZE / 2, puCenterY = pu.y * TILE_SIZE + TILE_SIZE / 2; const playerCenterX = player.x + player.width / 2, playerCenterY = player.y + player.height / 2; const dist = Math.hypot(puCenterX - playerCenterX, puCenterY - playerCenterY); if (dist < pu.size + player.width / 2) { player.activePowerUp = pu; powerUpsCollected++; if (pu.type === 'health') { player.health = Math.min(player.maxHealth, player.health + 50); } else { player.powerUpTimer = 10; } powerUps.splice(i, 1); } } }
        function draw() { if (!gameStarted) return; ctx.clearRect(0, 0, canvas.width, canvas.height); drawCachedMaze(); powerUps.forEach(pu => pu.draw()); player.draw(); enemies.forEach(e => e.draw()); projectiles.forEach(p => p.draw()); updateUI(); }
        function gameLoop(timestamp) { const deltaTime = (timestamp - lastTime) / 1000; lastTime = timestamp; update(deltaTime || timeStep); draw(); requestAnimationFrame(gameLoop); }
        function updateUI() { scoreEl.textContent = score; if (score > hiScore) { hiScore = score; localStorage.setItem('tronTanksHiScore', hiScore); } hiScoreEl.textContent = hiScore; enemiesLeftEl.textContent = enemies.length; const healthPercentage = (player.health / player.maxHealth) * 100; healthBarEl.style.width = `${healthPercentage}%`; }
        function togglePause() { if (!gameStarted) return; isPaused = !isPaused; pauseModal.classList.toggle('hidden'); pauseModal.classList.toggle('flex'); }
        function showGameOverModal() { 
            statTanks.textContent = tanksDerezzed;
            statShots.textContent = shotsFired;
            statPowerUps.textContent = powerUpsCollected;
            statLevels.textContent = level - 1;
            statScore.textContent = score;
            gameOverModal.classList.remove('hidden'); 
            gameOverModal.classList.add('flex'); 
        }
        window.addEventListener('keydown', e => { if (keys.hasOwnProperty(e.key)) keys[e.key] = true; if (e.key === 'p' || e.key === 'Escape') togglePause(); });
        window.addEventListener('keyup', e => { if (keys.hasOwnProperty(e.key)) keys[e.key] = false; });
        pauseButton.addEventListener('click', togglePause);
        resumeButton.addEventListener('click', togglePause);
        restartButton.addEventListener('click', () => { togglePause(); resetGame(); });
        playAgainButton.addEventListener('click', () => { gameOverModal.classList.add('hidden'); gameOverModal.classList.remove('flex'); resetGame(); });
        let turretMode = false;
        const dpadButtons = { upBtn: { key: 'ArrowUp' }, downBtn: { key: 'ArrowDown' }, leftBtn: { key: 'ArrowLeft' }, rightBtn: { key: 'ArrowRight' } };
        function handleDPad(btnId, isPressed) { const button = dpadButtons[btnId]; if (!button) return; if (turretMode) keys['Shift'] = isPressed; keys[button.key] = isPressed; }
        Object.keys(dpadButtons).forEach(id => { const btn = document.getElementById(id); btn.addEventListener('touchstart', (e) => { e.preventDefault(); handleDPad(id, true); }, { passive: false }); btn.addEventListener('touchend', (e) => { e.preventDefault(); handleDPad(id, false); }, { passive: false }); });
        const fireBtn = document.getElementById('fireBtn');
        fireBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[' '] = true; }, { passive: false });
        fireBtn.addEventListener('touchend', (e) => { e.preventDefault(); keys[' '] = false; }, { passive: false });
        const turretBtn = document.getElementById('turretBtn');
        turretBtn.addEventListener('touchstart', (e) => { e.preventDefault(); turretMode = true; }, { passive: false });
        turretBtn.addEventListener('touchend', (e) => { e.preventDefault(); turretMode = false; keys['Shift'] = false; }, { passive: false });
        function setMobileLayout(layout) { applyControlSettings(); localStorage.setItem('tronTanksHandedness', layout); }
        layoutLeftRadio.addEventListener('change', () => setMobileLayout('left'));
        layoutRightRadio.addEventListener('change', () => setMobileLayout('right'));
        const controlSettings = { dpad: { x: 20, y: 20 }, actions: { x: 20, y: 20 }, scale: 1, opacity: 0.7 };
        function applyControlSettings() { const dpad = mobileControls.querySelector('.d-pad'); const actions = mobileControls.querySelector('.action-buttons'); dpad.style.transform = `scale(${controlSettings.scale})`; dpad.style.opacity = controlSettings.opacity; actions.style.transform = `scale(${controlSettings.scale})`; actions.style.opacity = controlSettings.opacity; const handedness = layoutRightRadio.checked ? 'right' : 'left'; dpad.style.bottom = `${controlSettings.dpad.y}px`; actions.style.bottom = `${controlSettings.actions.y}px`; dpad.style.left = dpad.style.right = actions.style.left = actions.style.right = 'auto'; if (handedness === 'right') { dpad.style.left = `${controlSettings.dpad.x}px`; actions.style.right = `${controlSettings.actions.x}px`; } else { dpad.style.right = `${controlSettings.dpad.x}px`; actions.style.left = `${controlSettings.actions.x}px`; } }
        function saveControlSettings() { localStorage.setItem('tronTanksControlSettings', JSON.stringify(controlSettings)); }
        function loadControlSettings() { const saved = localStorage.getItem('tronTanksControlSettings'); if (saved) { const loaded = JSON.parse(saved); Object.assign(controlSettings, loaded); } applyControlSettings(); }
        
        function setupAdjustControls() {
            const template = document.getElementById('controlAdjustModalTemplate');
            const clone = template.content.cloneNode(true);
            canvasContainer.appendChild(clone);
            const scaleSlider = document.getElementById('scaleSlider');
            const opacitySlider = document.getElementById('opacitySlider');
            const closeAdjustControls = document.getElementById('closeAdjustControls');
            scaleSlider.value = controlSettings.scale;
            opacitySlider.value = controlSettings.opacity;
            scaleSlider.addEventListener('input', (e) => { controlSettings.scale = e.target.value; applyControlSettings(); });
            opacitySlider.addEventListener('input', (e) => { controlSettings.opacity = e.target.value; applyControlSettings(); });
            closeAdjustControls.addEventListener('click', () => { saveControlSettings(); document.getElementById('controlAdjustModal').remove(); mobileControls.classList.remove('is-adjusting'); isAdjustingControls = false; togglePause(); });
        }

        adjustControlsButton.addEventListener('click', () => { togglePause(); isAdjustingControls = true; setupAdjustControls(); mobileControls.classList.add('is-adjusting'); });
        
        let draggedControl = null, startX, startY, startControlX, startControlY;
        mobileControlsContainer.addEventListener('touchstart', e => { if (!isAdjustingControls) return; const target = e.target.closest('[data-control]'); if (target) { draggedControl = target.dataset.control; const touch = e.touches[0]; startX = touch.clientX; startY = touch.clientY; startControlX = controlSettings[draggedControl].x; startControlY = controlSettings[draggedControl].y; e.preventDefault(); } });
        window.addEventListener('touchmove', e => { if (!draggedControl) return; const touch = e.touches[0]; const deltaX = touch.clientX - startX; const deltaY = startY - touch.clientY; const handedness = layoutRightRadio.checked ? 'right' : 'left'; if ( (draggedControl === 'dpad' && handedness === 'right') || (draggedControl === 'actions' && handedness === 'left') ) { controlSettings[draggedControl].x = startControlX + deltaX; } else { controlSettings[draggedControl].x = startControlX - deltaX; } controlSettings[draggedControl].y = startControlY + deltaY; applyControlSettings(); });
        window.addEventListener('touchend', () => { draggedControl = null; });
        function resizeCanvas() { prevTileSize = TILE_SIZE; const container = canvasContainer; if (container.offsetHeight === 0) { requestAnimationFrame(resizeCanvas); return; } const availableHeight = container.offsetHeight, availableWidth = container.offsetWidth; const scaleX = availableWidth / (MAZE_WIDTH * 32), scaleY = availableHeight / (MAZE_HEIGHT * 32); const scale = Math.min(scaleX, scaleY); TILE_SIZE = Math.max(8, Math.floor(32 * scale)); if (TILE_SIZE === prevTileSize && mazeCanvas) return; canvas.width = TILE_SIZE * MAZE_WIDTH; canvas.height = TILE_SIZE * MAZE_HEIGHT; if (player) { const ratio = TILE_SIZE / prevTileSize; player.x *= ratio; player.y *= ratio; player.width = TILE_SIZE * 0.8; player.height = TILE_SIZE * 0.8; enemies.forEach(e => { e.x *= ratio; e.y *= ratio; e.width = TILE_SIZE * 0.8; e.height = TILE_SIZE * 0.8; }); } if(maze.length > 0) drawMazeToCache(); }
        window.addEventListener('resize', resizeCanvas);
        function startGame(mobile) {
            isMobile = mobile;
            startModal.style.display = 'none';
            gameUI.classList.remove('hidden');
            canvasContainer.classList.remove('hidden');
            if (isMobile) {
                document.body.classList.add('mobile-layout');
                mobileControlsContainer.style.display = 'block';
                adjustControlsButton.classList.remove('hidden');
                mobileLayoutOptions.classList.remove('hidden');
                loadControlSettings();
                const savedHandedness = localStorage.getItem('tronTanksHandedness') || 'right';
                if (savedHandedness === 'left') layoutLeftRadio.checked = true;
                else layoutRightRadio.checked = true;
                setMobileLayout(savedHandedness);
            }
            gameStarted = true;
            init();
            resizeCanvas();
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        desktopStartBtn.addEventListener('click', () => startGame(false));
        mobileStartBtn.addEventListener('click', () => startGame(true));

    </script>
</body>
</html>
