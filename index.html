<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Paranoids Labyrinth</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body {
            background-color: #000;
            color: #00ffff;
            font-family: 'Orbitron', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            text-align: center;
        }
        
        .game-wrapper {
            display: flex;
            flex-direction: column;
            height: 98vh; /* Use vh to ensure full height on mobile */
            width: 98vw;
            max-width: 600px;
        }

        #game-container {
            position: relative;
            flex: 1; /* Takes up 50% of the available vertical space */
            background: #000;
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px #00ffff, 0 0 10px #00ffff inset;
            border-radius: 10px;
            overflow: hidden;
            transition: box-shadow 0.5s ease-in-out, border-color 0.5s ease-in-out;
            margin-bottom: 5px; /* Add some space between game and controls */
        }
        
        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .info-panel {
            margin-top: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.2em;
            text-shadow: 0 0 5px #00ffff;
            width: 100%;
            padding: 0 5px;
        }

        #health-bar-container {
            width: 150px;
            height: 20px;
            border: 2px solid #00ff00;
            border-radius: 5px;
            box-shadow: 0 0 5px #00ff00;
        }

        #health-bar {
            height: 100%;
            background-color: #00ff00;
            transition: width 0.3s ease-in-out;
        }
        
        .pause-button {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1em;
            color: #000;
            background-color: #ff00ff;
            border: 2px solid #ff00ff;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 10px #ff00ff;
            transition: all 0.3s ease;
            z-index: 10;
        }
        .pause-button:hover {
            transform: scale(1.05);
        }
        .pause-button:active {
            transform: scale(1);
        }

        #message-box, #options-menu {
            display: none;
        }
        
        #start-menu, #message-box, #options-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff00ff;
            padding: 20px 40px;
            border-radius: 10px;
            box-shadow: 0 0 15px #ff00ff;
            z-index: 100;
            width: 80%;
            max-width: 400px;
        }

        #message-box h2, #start-menu h2, #options-menu h2 {
            margin: 0 0 10px;
            color: #ff00ff;
        }

        #message-box p, #start-menu p, #options-menu p {
            margin: 0 0 20px;
            font-size: 1.1em;
        }
        
        .game-button {
            padding: 10px 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1em;
            color: #000;
            background-color: #00ffff;
            border: 2px solid #00ffff;
            border-radius: 8px;
            cursor: pointer;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            box-shadow: 0 0 10px #00ffff;
            transition: all 0.3s ease;
            margin: 5px;
        }
        
        .game-button:hover {
            transform: scale(1.05);
            background-color: #33ffff;
            box-shadow: 0 0 20px #00ffff;
        }
        
        .game-button:active {
            transform: scale(1);
            box-shadow: 0 0 5px #00ffff;
        }
        
        .game-controls-container {
            flex: 1; /* Takes up the remaining 50% of vertical space */
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            box-sizing: border-box;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            margin-top: 5px;
            width: 100%;
        }

        .d-pad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 150px;
            height: 150px;
            background: #333;
            border-radius: 50%;
            box-shadow: 0 0 10px #00ffff;
        }
        
        .d-pad-btn {
            background: #555;
            border: 2px solid #00ffff;
            color: #00ffff;
            font-size: 1.5em;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .d-pad-btn:hover {
            background: #888;
            box-shadow: 0 0 5px #00ffff;
        }
        
        .d-pad-btn:active {
            background: #bbb;
            transform: scale(0.95);
        }

        .d-pad-btn.up { grid-area: 1 / 2 / 2 / 3; border-radius: 10px 10px 0 0; }
        .d-pad-btn.left { grid-area: 2 / 1 / 3 / 2; border-radius: 10px 0 0 10px; }
        .d-pad-btn.right { grid-area: 2 / 3 / 3 / 4; border-radius: 0 10px 10px 0; }
        .d-pad-btn.down { grid-area: 3 / 2 / 4 / 3; border-radius: 0 0 10px 10px; }
        .d-pad-center { grid-area: 2 / 2 / 3 / 3; background: #333; }

        .action-buttons {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            width: 150px;
            height: 150px;
            margin-left: 50px;
        }

        .action-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 2px solid #ff00ff;
            background-color: #cc00cc;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2em;
            cursor: pointer;
            box-shadow: 0 0 10px #ff00ff;
            transition: all 0.2s ease;
        }
        
        .action-btn:active {
            transform: scale(0.9);
            box-shadow: 0 0 5px #ff00ff;
        }
        
        .action-btn.fire {
            background-color: #ff0000;
            border-color: #ff0000;
            box-shadow: 0 0 10px #ff0000;
        }
        
        .action-btn.turret {
            background-color: #00ff00;
            border-color: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }

        .instructions {
            margin-top: 15px;
            font-size: 0.9em;
            color: #888;
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <div id="game-container">
            <canvas id="game-canvas"></canvas>
            <button class="pause-button" id="pause-button" style="display: none;">Pause</button>
        </div>

        <div class="game-controls-container">
            <div class="d-pad">
                <button id="up-btn" class="d-pad-btn up" data-direction="up">▲</button>
                <button id="left-btn" class="d-pad-btn left" data-direction="left">◄</button>
                <button id="right-btn" class="d-pad-btn right" data-direction="right">►</button>
                <button id="down-btn" class="d-pad-btn down" data-direction="down">▼</button>
                <div class="d-pad-center"></div>
            </div>
            <div class="action-buttons">
                <button id="fire-btn" class="action-btn fire">FIRE</button>
                <button id="turret-btn" class="action-btn turret">TURRET</button>
            </div>
        </div>
    </div>
    
    <div class="info-panel">
        <p>Score: <span id="score-display">0</span></p>
        <p>Hi-Score: <span id="hi-score-display">0</span></p>
        <p>Enemies Left: <span id="enemies-display">3</span></p>
        <p>Health: <div id="health-bar-container"><div id="health-bar"></div></div></p>
    </div>

    <!-- START: The start menu is now visible by default. -->
    <div id="start-menu">
        <h2>Space Paranoids Labyrinth</h2>
        <p>Use the D-Pad to move and the Fire button to shoot. Hold the Turret button and use the D-Pad to aim your turret.</p>
        <!-- The onclick attribute has been added here to directly call the startGame function -->
        <button id="start-game-btn" class="game-button" onclick="startGame()">Start Game</button>
        <button id="options-btn" class="game-button">Options</button>
    </div>
    <!-- END: The start menu is now visible by default. -->

    <div id="options-menu">
        <h2>Options</h2>
        <p>Controls and settings will be here.</p>
        <button id="back-to-start-btn" class="game-button">Back</button>
    </div>

    <div id="message-box">
        <h2 id="message-title">Game Over</h2>
        <p id="message-text">Your final score is: <span id="final-score">0</span></p>
        <button id="box-restart-button" class="game-button">Play Again</button>
    </div>
    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const hiScoreDisplay = document.getElementById('hi-score-display');
        const enemiesDisplay = document.getElementById('enemies-display');
        const messageBox = document.getElementById('message-box');
        const finalScoreDisplay = document.getElementById('final-score');
        const boxRestartButton = document.getElementById('box-restart-button');
        const healthBar = document.getElementById('health-bar');
        const gameContainer = document.getElementById('game-container');
        const pauseButton = document.getElementById('pause-button');
        
        // New UI Elements
        const startMenu = document.getElementById('start-menu');
        const optionsMenu = document.getElementById('options-menu');
        // The startGameButton element is no longer needed since we are using the onclick attribute in HTML.
        const optionsButton = document.getElementById('options-btn');
        const backToStartButton = document.getElementById('back-to-start-btn');
        const upButton = document.getElementById('up-btn');
        const downButton = document.getElementById('down-btn');
        const leftButton = document.getElementById('left-btn');
        const rightButton = document.getElementById('right-btn');
        const fireButton = document.getElementById('fire-btn');
        const turretButton = document.getElementById('turret-btn');

        let isGameOver = true;
        let isPaused = true;
        let score = 0;
        let highScore = localStorage.getItem('hiScore') || 0;
        let animationFrameId;
        let explosions = [];
        let powerUps = [];
        let lastPowerUpSpawn = 0;
        let isTransitioningLevel = false;
        let levelTimeoutId = null;
        let playerDefaultColor = '#00ffff';
        let playerIsFlashing = false;
        let defaultBorderColor = '#00ffff';
        let defaultBorderShadow = '0 0 20px #00ffff, 0 0 10px #00ffff inset';

        // Maze dimensions
        const MAZE_WIDTH = 13;
        const MAZE_HEIGHT = 13;
        let CELL_SIZE = 40;
        let maze = [];

        function generateMaze() {
            maze = Array(MAZE_HEIGHT).fill(null).map(() => Array(MAZE_WIDTH).fill(1));
            const stack = [];
            const startX = Math.floor(Math.random() * MAZE_WIDTH);
            const startY = Math.floor(Math.random() * MAZE_HEIGHT);
            stack.push({ x: startX, y: startY });
            maze[startY][startX] = 0;
            const directions = [{x: 0, y: 1}, {x: 0, y: -1}, {x: 1, y: 0}, {x: -1, y: 0}];
            while(stack.length > 0) {
                const current = stack[stack.length - 1];
                const neighbors = [];
                directions.forEach(dir => {
                    const nextX = current.x + dir.x * 2;
                    const nextY = current.y + dir.y * 2;
                    if (nextX >= 0 && nextX < MAZE_WIDTH && nextY >= 0 && nextY < MAZE_HEIGHT && maze[nextY][nextX] === 1) {
                        neighbors.push({ x: nextX, y: nextY, dir: dir });
                    }
                });
                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    maze[current.y + next.dir.y][current.x + next.dir.x] = 0;
                    maze[next.y][next.x] = 0;
                    stack.push({ x: next.x, y: next.y });
                } else {
                    stack.pop();
                }
            }
        }

        function drawMaze() {
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 10;
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (maze[y][x] === 1) {
                        ctx.beginPath();
                        ctx.rect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        ctx.stroke();
                    }
                }
            }
            ctx.shadowBlur = 0;
        }

        // Player (Tank)
        const player = {
            x: 0,
            y: 0,
            size: 20,
            baseSpeed: 3,
            currentSpeed: 3,
            baseFireRate: 300,
            currentFireRate: 300,
            health: 100,
            maxHealth: 100,
            color: playerDefaultColor,
            velocity: { x: 0, y: 0 },
            turretAngle: -Math.PI / 2,
            draw: function() {
                ctx.fillStyle = this.color;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                
                ctx.beginPath();
                ctx.rect(this.x, this.y, this.size, this.size);
                ctx.fill();
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(this.x + this.size / 2, this.y + this.size / 2);
                const turretLength = this.size * 1.0;
                const turretX = this.x + this.size / 2 + turretLength * Math.cos(this.turretAngle);
                const turretY = this.y + this.size / 2 + turretLength * Math.sin(this.turretAngle);
                ctx.lineTo(turretX, turretY);
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.shadowBlur = 0;
            },
            update: function() {
                const newX = this.x + this.velocity.x;
                const newY = this.y + this.velocity.y;
                if (!checkWallCollision(newX, newY, this.size)) {
                    this.x = newX;
                    this.y = newY;
                }
            }
        };

        function updateHealthBar() {
            const healthPercentage = (player.health / player.maxHealth) * 100;
            healthBar.style.width = `${healthPercentage}%`;
            healthBar.style.backgroundColor = healthPercentage > 50 ? '#00ff00' : (healthPercentage > 25 ? '#ffff00' : '#ff0000');
            healthBar.style.boxShadow = `0 0 5px ${healthBar.style.backgroundColor}`;
        }

        class Projectile {
            constructor(x, y, vx, vy, color, target = 'enemy') {
                this.x = x;
                this.y = y;
                this.size = 5;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.target = target;
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
            }
        }

        let projectiles = [];
        let enemyProjectiles = [];
        let powerUpSpawnTimer = 0;
        let powerUpSpawnInterval = 5000;

        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.size = 15;
                this.type = type;
                this.color = '';
                this.duration = 5000;
                if (type === 'health') this.color = '#00ff00';
                if (type === 'speed') this.color = '#ffff00';
                if (type === 'fireRate') this.color = '#ff00ff';
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(this.x + this.size / 2, this.y + this.size / 2, this.size / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        function spawnPowerUp() {
            const powerUpTypes = ['health', 'speed', 'fireRate'];
            const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
            let placed = false;
            let attempts = 0;
            while(!placed && attempts < 100) {
                const x = Math.floor(Math.random() * MAZE_WIDTH);
                const y = Math.floor(Math.random() * MAZE_HEIGHT);
                if (maze[y][x] === 0) {
                    const powerUp = new PowerUp(
                        x * CELL_SIZE + (CELL_SIZE - 15) / 2,
                        y * CELL_SIZE + (CELL_SIZE - 15) / 2,
                        type
                    );
                    powerUps.push(powerUp);
                    placed = true;
                }
                attempts++;
            }
        }

        class Enemy {
            constructor() {
                this.size = 20;
                this.x = 0;
                this.y = 0;
                this.speed = 2;
                this.color = '#ff9900';
                this.lastShot = Date.now();
                this.fireRate = 2000;
                this.vx = (Math.random() < 0.5 ? 1 : -1) * this.speed;
                this.vy = (Math.random() < 0.5 ? 1 : -1) * this.speed;
            }
            draw() {
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                
                ctx.beginPath();
                ctx.rect(this.x, this.y, this.size, this.size);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(this.x + this.size / 2, this.y + this.size / 2);
                ctx.lineTo(this.x + this.size / 2, this.y + this.size);
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
            update() {
                const newX = this.x + this.vx;
                const newY = this.y + this.vy;
                if (checkWallCollision(newX, newY, this.size)) {
                    const directions = [{x: 1, y: 0}, {x: -1, y: 0}, {x: 0, y: 1}, {x: 0, y: -1}];
                    directions.sort(() => Math.random() - 0.5);
                    let foundNewPath = false;
                    for (const dir of directions) {
                        const testX = this.x + dir.x * CELL_SIZE;
                        const testY = this.y + dir.y * CELL_SIZE;
                        if (!checkWallCollision(testX, testY, this.size)) {
                            this.vx = dir.x * this.speed;
                            this.vy = dir.y * this.speed;
                            foundNewPath = true;
                            break;
                        }
                    }
                    if (!foundNewPath) {
                        this.vx = -this.vx;
                        this.vy = -this.vy;
                    }
                } else {
                    this.x = newX;
                    this.y = newY;
                }
                if (Math.random() < 0.005) {
                    const directions = [{x: 1, y: 0}, {x: -1, y: 0}, {x: 0, y: 1}, {x: 0, y: -1}];
                    const newDir = directions[Math.floor(Math.random() * directions.length)];
                    this.vx = newDir.x * this.speed;
                    this.vy = newDir.y * this.speed;
                }
            }
            shoot() {
                if (Date.now() - this.lastShot > this.fireRate) {
                    enemyProjectiles.push(new Projectile(
                        this.x + this.size / 2, 
                        this.y + this.size, 
                        0,
                        3,
                        '#ff0000',
                        'player'
                    ));
                    this.lastShot = Date.now();
                }
            }
        }

        let enemies = [];

        class Explosion {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.particles = [];
                for (let i = 0; i < 10; i++) {
                    this.particles.push({
                        x: 0,
                        y: 0,
                        radius: Math.random() * 2 + 1,
                        velocity: {
                            x: (Math.random() - 0.5) * 5,
                            y: (Math.random() - 0.5) * 5
                        },
                        alpha: 1
                    });
                }
            }
            draw() {
                this.particles.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(this.x + p.x, this.y + p.y, p.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${parseInt(this.color.slice(1,3), 16)}, ${parseInt(this.color.slice(3,5), 16)}, ${parseInt(this.color.slice(5,7), 16)}, ${p.alpha})`;
                    ctx.fill();
                });
            }
            update() {
                this.particles.forEach(p => {
                    p.x += p.velocity.x;
                    p.y += p.velocity.y;
                    p.alpha -= 0.05;
                });
                return this.particles.every(p => p.alpha <= 0);
            }
        }
        
        function checkCollision(obj1, obj2) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (obj1.size + obj2.size) / 2;
        }

        function checkWallCollision(x, y, size) {
            const playerGridX = Math.floor(x / CELL_SIZE);
            const playerGridY = Math.floor(y / CELL_SIZE);
            const playerGridX2 = Math.floor((x + size) / CELL_SIZE);
            const playerGridY2 = Math.floor((y + size) / CELL_SIZE);
            if (playerGridX < 0 || playerGridX >= MAZE_WIDTH ||
                playerGridY < 0 || playerGridY >= MAZE_HEIGHT ||
                playerGridX2 < 0 || playerGridX2 >= MAZE_WIDTH ||
                playerGridY2 < 0 || playerGridY2 >= MAZE_HEIGHT) {
                return true;
            }
            if (maze[playerGridY][playerGridX] === 1 || 
                maze[playerGridY][playerGridX2] === 1 ||
                maze[playerGridY2][playerGridX] === 1 ||
                maze[playerGridY2][playerGridX2] === 1) {
                return true;
            }
            return false;
        }

        function gameOver() {
            isGameOver = true;
            isPaused = true;
            cancelAnimationFrame(animationFrameId);
            finalScoreDisplay.textContent = score;
            document.getElementById('message-title').textContent = 'Game Over';
            document.getElementById('message-text').style.display = 'block';
            boxRestartButton.style.display = 'block';
            messageBox.style.display = 'block';
            pauseButton.style.display = 'none';

            if (score > highScore) {
                highScore = score;
                hiScoreDisplay.textContent = highScore;
                localStorage.setItem('hiScore', highScore);
            }
        }

        function winLevel() {
            isTransitioningLevel = true;
            isPaused = true;
            cancelAnimationFrame(animationFrameId);

            // Add the 75-point bonus for completing the level
            score += 75;
            scoreDisplay.textContent = score;
            document.getElementById('message-title').textContent = 'Level Complete!';
            document.getElementById('message-text').textContent = `Your current score is: ${score}`;
            boxRestartButton.style.display = 'none';
            messageBox.style.display = 'block';

            levelTimeoutId = setTimeout(() => {
                startNewLevel();
            }, 2000);
        }
        
        let powerUpEffectTimeoutId = null;
        function applyPowerUpEffect(color, duration) {
            if (powerUpEffectTimeoutId) {
                clearTimeout(powerUpEffectTimeoutId);
            }
            
            gameContainer.style.boxShadow = `0 0 20px ${color}, 0 0 10px ${color} inset`;
            gameContainer.style.borderColor = color;
            
            powerUpEffectTimeoutId = setTimeout(() => {
                gameContainer.style.boxShadow = defaultBorderShadow;
                gameContainer.style.borderColor = defaultBorderColor;
            }, duration);
        }

        function flashPlayerRed() {
            if (playerIsFlashing) return;
            playerIsFlashing = true;
            player.color = '#ff0000';
            gameContainer.style.boxShadow = `0 0 20px #ff0000, 0 0 10px #ff0000 inset`;
            gameContainer.style.borderColor = '#ff0000';
            setTimeout(() => {
                player.color = playerDefaultColor;
                gameContainer.style.boxShadow = defaultBorderShadow;
                gameContainer.style.borderColor = defaultBorderColor;
                playerIsFlashing = false;
            }, 500);
        }

        function gameLoop() {
            if (isGameOver || isPaused || isTransitioningLevel) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMaze();

            powerUpSpawnTimer++;
            if (powerUpSpawnTimer > 600) {
                spawnPowerUp();
                powerUpSpawnTimer = 0;
            }
            
            powerUps.forEach(p => p.draw());

            updatePlayerMovement();
            player.update();
            player.draw();

            enemies.forEach((enemy, enemyIndex) => {
                enemy.update();
                enemy.draw();
                enemy.shoot();

                projectiles.forEach((projectile, projIndex) => {
                    if (checkCollision(projectile, enemy)) {
                        explosions.push(new Explosion(enemy.x + enemy.size/2, enemy.y + enemy.size/2, enemy.color));
                        enemies.splice(enemyIndex, 1);
                        projectiles.splice(projIndex, 1);
                        score += 10;
                        scoreDisplay.textContent = score;
                        enemiesDisplay.textContent = enemies.length;
                    }
                });
            });

            powerUps.forEach((p, index) => {
                if (checkCollision(player, p)) {
                    applyPowerUpEffect(p.color, p.duration);
                    if (p.type === 'health') {
                        player.health = Math.min(player.health + 25, player.maxHealth);
                        updateHealthBar();
                    } else if (p.type === 'speed') {
                        player.currentSpeed = player.baseSpeed * 1.5;
                        setTimeout(() => player.currentSpeed = player.baseSpeed, p.duration);
                    } else if (p.type === 'fireRate') {
                        player.currentFireRate = player.baseFireRate * 0.5;
                        setTimeout(() => player.currentFireRate = player.baseFireRate, p.duration);
                    }
                    powerUps.splice(index, 1);
                }
            });

            projectiles.forEach((projectile, projIndex) => {
                projectile.update();
                projectile.draw();
                if (checkWallCollision(projectile.x, projectile.y, projectile.size) || projectile.y < -projectile.size || projectile.x < -projectile.size || projectile.x > canvas.width + projectile.size) {
                    projectiles.splice(projIndex, 1);
                }
            });
            
            enemyProjectiles.forEach((projectile, projIndex) => {
                projectile.update();
                projectile.draw();
                if (checkCollision(projectile, player)) {
                    explosions.push(new Explosion(projectile.x, projectile.y, projectile.color));
                    enemyProjectiles.splice(projIndex, 1);
                    player.health -= 25;
                    updateHealthBar();
                    flashPlayerRed();
                    if (player.health <= 0) {
                        gameOver();
                    }
                }
                if (checkWallCollision(projectile.x, projectile.y, projectile.size) || projectile.y > canvas.height + projectile.size) {
                    enemyProjectiles.splice(projIndex, 1);
                }
            });
            
            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                explosion.draw();
                if (explosion.update()) {
                    explosions.splice(i, 1);
                }
            }

            if (enemies.length === 0) {
                winLevel();
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (keys['Shift']) {
                if (e.key === 'ArrowUp' || e.key === 'w') {
                    player.turretAngle = -Math.PI / 2;
                } else if (e.key === 'ArrowDown' || e.key === 's') {
                    player.turretAngle = Math.PI / 2;
                } else if (e.key === 'ArrowLeft' || e.key === 'a') {
                    player.turretAngle = Math.PI;
                } else if (e.key === 'ArrowRight' || e.key === 'd') {
                    player.turretAngle = 0;
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        let lastPlayerShot = Date.now();
        function updatePlayerMovement() {
            player.velocity.x = 0;
            player.velocity.y = 0;
            if (keys['ArrowUp'] || keys['w'] || keys['up']) player.velocity.y = -player.currentSpeed;
            if (keys['ArrowDown'] || keys['s'] || keys['down']) player.velocity.y = player.currentSpeed;
            if (keys['ArrowLeft'] || keys['a'] || keys['left']) player.velocity.x = -player.currentSpeed;
            if (keys['ArrowRight'] || keys['d'] || keys['right']) player.velocity.x = player.currentSpeed;
            
            // Check for both keyboard and button presses for shooting
            if ((keys[' '] || keys['fire']) && Date.now() - lastPlayerShot > player.currentFireRate) {
                const projectileSpeed = 7;
                projectiles.push(new Projectile(
                    player.x + player.size / 2, 
                    player.y + player.size / 2, 
                    projectileSpeed * Math.cos(player.turretAngle), 
                    projectileSpeed * Math.sin(player.turretAngle), 
                    '#00ffff'
                ));
                lastPlayerShot = Date.now();
            }
        }

        function resizeCanvas() {
            const gameContainerHeight = document.getElementById('game-container').clientHeight;
            const gameContainerWidth = document.getElementById('game-container').clientWidth;
            canvas.width = gameContainerWidth;
            canvas.height = gameContainerHeight;
            CELL_SIZE = Math.floor(Math.min(canvas.width / MAZE_WIDTH, canvas.height / MAZE_HEIGHT));
            player.size = CELL_SIZE * 0.4;
            // Recalculate player position to center it in the starting maze cell
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (maze[y][x] === 0) {
                        player.x = x * CELL_SIZE + (CELL_SIZE - player.size) / 2;
                        player.y = y * CELL_SIZE + (CELL_SIZE - player.size) / 2;
                        return;
                    }
                }
            }
        }
        
        window.addEventListener('resize', resizeCanvas);
        
        function spawnEnemies() {
            const numEnemies = Math.min(5, Math.floor(MAZE_WIDTH * MAZE_HEIGHT / 20));
            enemies = [];
            let placed = 0;
            while (placed < numEnemies) {
                const x = Math.floor(Math.random() * MAZE_WIDTH);
                const y = Math.floor(Math.random() * MAZE_HEIGHT);
                const enemy = new Enemy();
                enemy.x = x * CELL_SIZE + (CELL_SIZE - enemy.size) / 2;
                enemy.y = y * CELL_SIZE + (CELL_SIZE - enemy.size) / 2;
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                if (maze[y][x] === 0 && distance > 200) {
                    enemies.push(enemy);
                    placed++;
                }
            }
            enemiesDisplay.textContent = enemies.length;
        }

        function showStartMenu() {
            isGameOver = true;
            isPaused = true;
            cancelAnimationFrame(animationFrameId);
            startMenu.style.display = 'block';
            optionsMenu.style.display = 'none';
            messageBox.style.display = 'none';
            pauseButton.style.display = 'none';
        }

        function showOptionsMenu() {
            startMenu.style.display = 'none';
            optionsMenu.style.display = 'block';
        }

        function startGame() {
            // This is a test message to confirm the function is being called.
            console.log("Starting game...");
            
            // Hides the start menu when the game begins.
            startMenu.style.display = 'none';
            
            if (levelTimeoutId) {
                clearTimeout(levelTimeoutId);
                levelTimeoutId = null;
            }
            isGameOver = false;
            isPaused = false;
            score = 0;
            isTransitioningLevel = false;
            projectiles = [];
            enemyProjectiles = [];
            explosions = [];
            powerUps = [];
            player.health = player.maxHealth;
            player.currentSpeed = player.baseSpeed;
            player.currentFireRate = player.baseFireRate;
            scoreDisplay.textContent = score;
            messageBox.style.display = 'none';
            pauseButton.style.display = 'block';
            updateHealthBar();

            generateMaze();
            resizeCanvas();
            spawnEnemies();
            spawnPowerUp();
            if (powerUpEffectTimeoutId) {
                clearTimeout(powerUpEffectTimeoutId);
            }
            gameContainer.style.boxShadow = defaultBorderShadow;
            gameContainer.style.borderColor = defaultBorderColor;
            gameLoop();
        }

        function startNewLevel() {
            isTransitioningLevel = false;
            isPaused = false;
            messageBox.style.display = 'none';
            projectiles = [];
            enemyProjectiles = [];
            explosions = [];
            powerUps = [];
            player.currentSpeed = player.baseSpeed;
            player.currentFireRate = player.baseFireRate;

            scoreDisplay.textContent = score;
            enemiesDisplay.textContent = enemies.length;
            updateHealthBar();
            if (powerUpEffectTimeoutId) {
                clearTimeout(powerUpEffectTimeoutId);
            }
            gameContainer.style.boxShadow = defaultBorderShadow;
            gameContainer.style.borderColor = defaultBorderColor;
            generateMaze();
            resizeCanvas();
            spawnEnemies();
            spawnPowerUp();
            gameLoop();
        }

        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                cancelAnimationFrame(animationFrameId);
                document.getElementById('message-title').textContent = 'Game Paused';
                document.getElementById('message-text').textContent = 'Press Resume to continue.';
                boxRestartButton.style.display = 'block';
                boxRestartButton.textContent = 'Resume';
                messageBox.style.display = 'block';
            } else {
                boxRestartButton.textContent = 'Play Again';
                messageBox.style.display = 'none';
                gameLoop();
            }
        }

        function setupEventListeners() {
            // Touch/Mouse event handling for new controls
            const moveButtons = {
                'up': upButton, 'down': downButton, 'left': leftButton, 'right': rightButton
            };

            const handleStart = (direction) => {
                if (isPaused) return;
                keys[direction] = true;
                if (keys['turret']) { // If turret button is held down
                    if (direction === 'up') player.turretAngle = -Math.PI / 2;
                    if (direction === 'down') player.turretAngle = Math.PI / 2;
                    if (direction === 'left') player.turretAngle = Math.PI;
                    if (direction === 'right') player.turretAngle = 0;
                }
            };
            const handleEnd = (direction) => {
                keys[direction] = false;
            };

            for (const direction in moveButtons) {
                moveButtons[direction].addEventListener('mousedown', () => handleStart(direction));
                moveButtons[direction].addEventListener('mouseup', () => handleEnd(direction));
                moveButtons[direction].addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    handleStart(direction);
                });
                moveButtons[direction].addEventListener('touchend', (e) => {
                    e.preventDefault();
                    handleEnd(direction);
                });
            }

            fireButton.addEventListener('mousedown', () => keys['fire'] = true);
            fireButton.addEventListener('mouseup', () => keys['fire'] = false);
            fireButton.addEventListener('touchstart', (e) => { e.preventDefault(); keys['fire'] = true; });
            fireButton.addEventListener('touchend', (e) => { e.preventDefault(); keys['fire'] = false; });

            turretButton.addEventListener('mousedown', () => keys['turret'] = true);
            turretButton.addEventListener('mouseup', () => keys['turret'] = false);
            turretButton.addEventListener('touchstart', (e) => { e.preventDefault(); keys['turret'] = true; });
            turretButton.addEventListener('touchend', (e) => { e.preventDefault(); keys['turret'] = false; });
            
            // This is now handled directly in the HTML with onclick="startGame()"
            // startGameButton.addEventListener('click', startGame); 
            optionsButton.addEventListener('click', showOptionsMenu);
            backToStartButton.addEventListener('click', showStartMenu);
            boxRestartButton.addEventListener('click', () => {
                if (isGameOver) {
                    startGame();
                } else {
                    togglePause();
                }
            });
            pauseButton.addEventListener('click', togglePause);
        }

        window.onload = function() {
            hiScoreDisplay.textContent = highScore;
            generateMaze();
            resizeCanvas();
            setupEventListeners();
        };

    </script>
</body>
</html>
